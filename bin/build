#!/usr/bin/env node
const fs = require("fs");
const path = require("path");
const { parse, stringify } = require("svgson");
const util = require("util");
const { camelClassCase } = require("camel-class-case");
const Entities = require("html-entities").AllHtmlEntities;

const entities = new Entities();

// Promisfy nodejs
const fsReaddir = util.promisify(fs.readdir);
const fsReadFile = util.promisify(fs.readFile);
const fsWriteFile = util.promisify(fs.writeFile);

// Read in our icons
const iconsPath = path.resolve(__dirname, "../node_modules/@mapbox/maki/icons");
const componentPath = path.resolve(__dirname, "../src/icons");

// Work through reading in each svg
(async () => {
  const files = (await fsReaddir(iconsPath)).filter(file => /.svg$/.test(file));

  const parts = [];

  for (let file of files) {
    // Name the svg
    const originalShortName = file.replace(/.svg$/, "");
    const name = camelClassCase(originalShortName);
    // Obtain the source
    const source = await fsReadFile(path.resolve(iconsPath, file), "utf-8");
    const svg = await parse(source);
    // Write the component
    const part = { name, svg, originalShortName };
    parts.push(part);
    await writeComponent(part);
  }

  await writeIndex(parts);

  console.log("Completed");
})();

// Write out the component source
const writeComponent = async ({ name, svg, originalShortName }) => {
  const output = path.resolve(componentPath, `${originalShortName}.tsx`);

  const content = `[${svg.children.map((p, i) => asReact(p, i)).join(",")}]`;

  const contents = `
import React from 'react';
import createSvgIcon from '../utils/create-svg-icon';

export const paths:string[] = [
  ${svg.children
    .map(p =>
      `\`${entities.decode(p.attributes.d).replace("\n", "")}\`\n`.trim()
    )
    .join("\n  ,")}
];

export default createSvgIcon(
  ${content},
  '${name}'
);
`;
  await fsWriteFile(output, contents);
};

const asReact = (element, i) => {
  if (!element) {
    return "";
  }
  let str = "";
  str += `<${element.name} key='s-${i}'`;
  // Attributes
  if (element.attributes) {
    const attributes = [];
    Object.keys(element.attributes).forEach(key => {
      if (key === "d") {
        attributes.push(`d={paths[${i}]}`);
      } else {
        attributes.push(`${key}='${element.attributes[key]}'`);
      }
    });
    if (attributes.length) {
      str += ` ${attributes.join(" ")}`;
    }
  }

  // Process the next element
  if (!element.children.length || element.value) {
    str += `/>`;
  } else {
    str += ">";
    if (element.value) {
      str += element.value;
    }
    str += element.children.map(asReact).join("");
    str += `</${element.name}>`;
  }

  return str;
};

const writeIndex = async parts => {
  const exported = parts.map(part => ({
    package: `export { default as ${part.name} } from './icons/${part.originalShortName}';\nimport { paths as paths${part.name} } from './icons/${part.originalShortName}';`,
    part: `paths['${part.originalShortName}'] = { paths: paths${part.name} };`
  }));

  const template = exports => {
    return `
${exports.map(e => e.package).join("\n")}
type PathsMap = {
  [key:string]: {
    paths: string[]
  }
}
const paths:PathsMap = {};
${exports.map(e => e.part).join("\n")}
export const iconsMap = paths;
`;
  };

  await fsWriteFile(
    path.resolve(componentPath, "../index.tsx"),
    template(exported)
  );

  const minimal11 = exported
    .filter(f => /11';$/.test(f.package))
    .map(f => ({
      package: f.package.replace(/11 }/g, " }"),
      part: f.part.replace(/-11'/g, "'").replace(/11 }/g, " }")
    }));
  await fsWriteFile(
    path.resolve(componentPath, "../index-11.tsx"),
    template(minimal11)
  );

  const minimal15 = exported
    .filter(f => /15';$/.test(f.package))
    .map(f => ({
      package: f.package.replace(/15 }/g, " }"),
      part: f.part.replace(/-15'/g, "'").replace(/15 }/g, " }")
    }));
  await fsWriteFile(
    path.resolve(componentPath, "../index-15.tsx"),
    template(minimal15)
  );
};
